---
layout: single
title: "An example of creating modular code in R - Efficient scientific programming"
excerpt: "This lesson provides an example of modularizing code in R. "
authors: ['Carson Farmer', 'Leah Wasser']
modified: '`r format(Sys.time(), "%Y-%m-%d")`'
category: [course-materials]
class-lesson: ['intro-APIs-r']
permalink: /course-materials/earth-analytics/week-10/apis2-r/
nav-title: 'JSON & RESTful APIs'
week: 10
sidebar:
  nav:
author_profile: false
comments: true
order: 3
---

{% include toc title="In This Lesson" icon="file-text" %}

<div class='notice--success' markdown="1">

## <i class="fa fa-graduation-cap" aria-hidden="true"></i> Learning Objectives

After completing this tutorial, you will be able to:

*

## <i class="fa fa-check-square-o fa-2" aria-hidden="true"></i> What you need

You will need a computer with internet access to complete this lesson and the
data that we already downloaded for week 6 of the course.

{% include/data_subsets/course_earth_analytics/_data-week6-7.md %}
</div>

```{r echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning=FALSE)

```

In the previous lesson, we learned how to access human readable text files data
programmatically using:

1. `download.file()` to download a file to your computer and work with it
1. `read.csv()` to read in a tabular file stored on a web location.
1. using `getURL()` to read in data files that may be secure (https://) or that require more advanced protocols.

In this lesson, we will learn more about API interfaces - which return data that
are **machine readable** and thus are more efficient - particularly for larger
data that contain hierarchical structures. In this lesson, the `getURL()`
function will become more valuable to us as we parse data accessed from an API.

```{r}
#NOTE: if you have problems with ggmap, try to install from github
#devtools::install_github("dkahle/ggmap")
#devtools::install_github("hadley/ggplot2")
library(ggmap)
library(ggplot2)

library("knitr")
library("dplyr")
library("RCurl")
```

## Review

Remember that in the first lesson in this module, we discussed **REST**ful APIs.
The request to an **REST**ful API includes a:

1. URL which defines the base location of the data on the web server (online url)
2. The request which includes the URL AND the associated parameters required to access a particular subset of the data that we wish to access

When you send the request, the web API returns one of the following:

 1. The data that we requested or
 2. A *failed to return* message which tells us that something was wrong with our request.

Next, we will use a REST API available to grab data from the <a href="https://data.colorado.gov" target="_blank">Colorado Information Marketplace</a>.

### Colorado Population Projections

The <a href="https://data.colorado.gov" target="_blank">Colorado Information Marketplace</a>
is a comprehensive data warehouse that contains a wide range of Colorado-specific
open datasets available via a **REST**ful API called the Socrata Open Data API (SODA).

There are lots of API *endpoints* or data sets available via this API. One
endpoint contains
<a href="https://data.colorado.gov/resource/tv8u-hswn.json" target="_blank">Colorado Population Projections:</a>.
If you go to this site, you will see data returned
in a `JSON` format. These data include population estimates for *males* and
*females* for every *county* in Colorado for every *year* from 1990 to 2040 for
multiple *age* groups!

## About JSON
Before we go any further, let's take a moment to describe the **J**ava**S**cript
**O**bject **N**otation or **JSON** data structure.
JSON is an ideal format for larger data specifically that have a hierarchical
structured relationship.

The structure of a JSON object is as follows:

* The data is in name/value pairs
* Data is separated by commas
* Curly braces `{}` hold objects
* Square brackets `[]` hold arrays
* Each data element is enclosed with quotes `""` if it is a character, or without quotes if it is a numeric value

```json
 { "name":"Chaya" }
```

```json
{ "name":"Chaya", "age":55, "city":"Boulder", "type":"Canine" }
```

Notice that the data above are structured. Thus, each element contains a particular
object name. (name, age, city, etc). This is similar to column headings in a .csv.
However, the JSON structure can also be nested. Like this:

```json
{"students":[
    { "firstName":"Serena", "lastName":"Williams" },
    { "firstName":"Boe", "lastName":"Diddly" },
    { "firstName":"Al", "lastName":"Gore" }
]}
```

The ability to store nested or hierarchical data within a text file structure makes
JSON a powerful format to use as we are working with larger datasets.


### JSON data structures

JSON can store any of the following data types:

* strings
* numbers
* objects (JSON object)
* arrays
* booleans (TRUE / FALSE)
* null

Now that we understand a bit about the JSON data structure, let's go back to
grabbing JSON data from an API.

### URL Parameters

Using `URL` parameters, we can define a more specific request to limit what data
we get back in response to our API request. For example, if we only want data for
Boulder, Colorado, we can query just that subset of the data using the RESTful call.

note the **?&county=Boulder** part of the url:

<a href="https://data.colorado.gov/resource/tv8u-hswn.json?&county=Boulder" target="_blank">Like this - https://data.colorado.gov/resource/tv8u-hswn.json?&county=Boulder</a>.

Parameters associated with accessing data using this API are <a href="https://dev.socrata.com/foundry/data.colorado.gov/tv8u-hswn" target="_blank">documented here</a>.

## Using the Colorado SODA API

The Colorado `SODA` API allows us to write 'queries' that filter out the exact
subset of the data that we want. Here's the API `URL`
for population projections for females who live in Boulder that are age 20--40
for the years 2016-2025:

```html
https://data.colorado.gov/resource/tv8u-hswn.json?$where=age between 20 and 40 and year between 2016 and 2025&county=Boulder&$select=year,age,femalepopulation
```

<a href="https://data.colorado.gov/resource/tv8u-hswn.json?$where=age between 20 and 40 and year between 2016 and 2025&county=Boulder&$select=year,age,femalepopulation" target="_blank">Click here to view data. (JSON format)</a>.

### API Response

The data that are returned from an API **request** are called the **response**.
The format of the returned data or the **response** is most often in the form of
plain text 'file' such as `JSON` or `.csv`.

NOTE: <a href="https://dev.socrata.com/docs/formats/index.html" target="_blank">For many APIs, you can specify the file that you want to be returned</a>

## Accessing API Data via getURL

We will use the `getURL()` in the same way that we used it before. However, this
time we will add the `URL` parameters that specify which subset of the data
that we want to access.

```{r}
# Base URL path
base_url = "https://data.colorado.gov/resource/tv8u-hswn.json?"
full_url = paste0(base_url, "county=Boulder",
              "&$where=age between 20 and 40",
              "&$select=year,age,femalepopulation")
# view full url
full_url
# get the data from the specified url
pop_proj_data = getURL(URLencode(full_url))

#base_url = "https://data.colorado.gov/resource/tv8u-hswn.json?"
#res = getForm(base_url, county="Boulder",
#              age="BOULDER")
```

Since these data are in a `JSON` data structure, we'll need to parse them into
a format that we can work with in R.


```{r}
# view JSON data structure
head(pop_proj_data)
```

Lucky for us the `rjson` and `jsonlite` packages
can help us work with JSON structured data.

```{r}
library(rjson)
library(jsonlite)

# Convert JSON to data frame
pop_proj_data_df = fromJSON(pop_proj_data)
#unlist(pop_proj_data_df)
head(pop_proj_data_df)

# turn columns to numeric and remove NA values
pop_proj_data_df <- pop_proj_data_df %>%
  mutate_each_(funs(as.numeric), c( "age", "year", "femalepopulation"))

```

The code above uses dplyr pipes to mutate or change 3 columns in our data.frame
to a numeric data type. Is it the same as running the code below on each column
of the data.

```{r, eval=FALSE}
# convert EACH row to a numeric format
# note this is the clunky way to do what we did above with dplyr!
pop_proj_data_df$age <- as.numeric(pop_proj_data_df$age)
pop_proj_data_df$year <- as.numeric(pop_proj_data_df$year)
pop_proj_data_df$femalepopulation <- as.numeric(pop_proj_data_df$femalepopulation)

# OR use the apply function to convert all rows in the DF to numbers
#pops <- as.data.frame(lapply(pop_proj_data_df, as.numeric))


```

Once we have converted the JSON data into a data.frame format that R can work with,
we can plot the data using `ggplot()`.


```{r plot_pop_proj}
# plot the data
ggplot(pop_proj_data_df, aes(x=year, y=femalepopulation,
  group=factor(age), color=age)) + geom_line() +
      labs(x="Year",
           y="Female Population",
          title="Projected Female Population",
          subtitle = "Boulder, CO: 1990 - 2040")
```

```{r echo=FALSE, eval=FALSE}

# some code i don't use that is fancier...
# fromJSON(res) %>% as.data.frame

# pops = do.call("rbind", pop_proj_data_df)  # Combine rows
# Convert to data.frame with numeric columns
# pops = as.data.frame(apply(pops, 2, as.numeric))
```

- `getForm` allows us to treat an API more like an `R` function
    - Here, we're using the [DWR Current Surface Water Conditions](https://data.colorado.gov/Water/DWR-Current-Surface-Water-Conditions-Map-Statewide/j5pc-4t32) via `SODA`


https://data.colorado.gov/Water/DWR-Current-Surface-Water-Conditions-Map-Statewide/j5pc-4t32

```{r}

water_base_url = "https://data.colorado.gov/resource/j5pc-4t32.json?"
water_full_url = paste0(water_base_url, "station_status=Active",
            "&county=BOULDER")
water_data = getURL(URLencode(water_full_url))
water_data_df <- fromJSON(water_data)
head(water_data_df)
str(water_data_df)
```

Remember that the JSON structure is hierarchical and often NESTED. In this case,
we have a nested data.frame within a data frame.
```{r}

water_data_df$location
water_data_df$location$latitude
```

We can remove the nesting using the flatten() function in R! Creates 2 new columns
in our data.frame. One for latitute and one for longitude. Notice that the name
of each new column contains the name of the previously nested data.frame followed
by a period, and then the column name. For example

`location.latitude`


```{r}
# remove the nested data frame
water_data_df <- flatten(water_data_df, recursive = TRUE)
water_data_df$location.latitude

```
Now we can clean up the data. Notice that our longitude and latitude are in quotes.
What does this mean about the structure of the data?

```{r}
str(water_data_df$location.latitude)
```


```{r}
# turn columns to numeric and remove NA values
water_data_df <- water_data_df %>%
  mutate_each_(funs(as.numeric), c( "amount", "location.longitude", "location.latitude")) %>%
  filter(!is.na(location.latitude))
```

Now we can plot the data

```{r water_data_plot1}
ggplot(water_data_df, aes(location.longitude, location.latitude, size=amount,
  color=station_type)) +
  geom_point() + coord_equal() +
      labs(x="Year",
           y="Female Population",
          title="Projected Female Population",
          subtitle = "Boulder, CO: 1990 - 2040")

```


It is often useful to explore you geospatial data in context (that's why `GIS` is so useful!). But instead of exporting your data to a shapefile and working in `QGIS` or similar, we can create maps directly in `R`...

Basic Mapping in R

- That last 'map' was really just a scatterplot of long/lat, with some minor aesthetic tweaks
- The `ggmap` package provides an interface to Google maps and others
    - So we can download 'basemaps' on the fly and plot them:

```{r create_ggmap}
boulder <- get_map(location="Boulder, CO, USA",
                  source="google", crop=FALSE, zoom=10)
ggmap(boulder) +
  geom_point(data=water_data_df, aes(location.longitude, location.latitude, size=amount,
  color=factor(station_type)))
```




<div class="notice--info" markdown="1">

## Additional Resources

* <a href="https://blog.datafiniti.co/4-reasons-you-should-use-json-instead-of-csv-2cac362f1943" target="_blank">why you should use JSON instead of csv.</a>
* <a href="https://www.w3schools.com/js/js_json_intro.asp" target="_blank">W3schools JSON intro </a>

</div>



***

## Review - about APIs

Remember we have covered

* where they can get information to figure out how to get the data
* show the website
* steps - what they need to know
* download data
* homework - maybe have them download data for different age ranges and some other county?
* they can use the API documentation to figure out what to parse...
